[
["index.html", "Analysis of single-cell RNA-seq data 1 About the course 1.1 Registration 1.2 GitHub 1.3 License 1.4 Prerequisites", " Analysis of single-cell RNA-seq data Vladimir Kiselev, Tallulah Andrews and Martin Hemberg 2016-03-31   1 About the course Recent technological advances have made it possible to obtain genome-wide transcriptome data from single cells using high-throughput sequencing (scRNA-seq). The main advantage of scRNA-seq is that the cellular resolution and the genome wide scope makes it possible to address issues that are intractable using other methods, e.g. bulk RNA-seq or single-cell RT-qPCR. However, to analyze scRNA-seq data, novel methods are required and some of the underlying assumptions for the methods developed for bulk RNA-seq experiments are no longer valid. In this course we will be surveying the existing problems as well as the available computational and statistical frameworks available for the analysis of scRNA-seq. The course is taught through the University of Cambridge Bioinformatics training unit, but the material found on these pages is meant to be used for anyone interested in learning about computational analysis of scRNA-seq data. If you have any comments or suggestions about the material, please do not hesitate to contact (add link!) us.  1.1 Registration http://training.csx.cam.ac.uk/bioinformatics/event/1755391   1.2 GitHub https://github.com/hemberg-lab/scRNA.seq.course   1.3 License Creative Commons Attribution-NoDerivatives 4.0 International License   1.4 Prerequisites The course is intended for those who have basic familiarity with Unix and the R scripting language. We will also assume that you are familiar with mapping and analysing bulk RNA-seq data as well as with the commonly available computational tools. We recommend attending the Introduction to RNA-seq and ChIP-seq data analysis or the Analysis of high-throughput sequencing data with Bioconductor before attending this course.   "],
["technical-requirements.html", "2 Technical requirements", " 2 Technical requirements This course is based on the popular programming language R. However, one of the methods that we describe (SNN-Cliq) is only partly R-based. It makes a simple python call from R and requires a user to have write permissions to the current directory. You also need to download this file and put it in the ~/snn-cliq/ directory. Before running the course exercises, you also need to install the following R packages: devtools for installing packages from GitHub: install.packages(&quot;devtools&quot;) scRNA.seq.funcs - R package containing our functions used in this course: devtools::install_github(&quot;hemberg-lab/scRNA.seq.funcs&quot;) mvoutlier - for an automatic outlier detection in the scater package. install.packages(&quot;mvoutlier&quot;) M3D for identification of important and DE genes, developed by Tallulah Andrews: devtools::install_github(&quot;tallulandrews/M3D&quot;, ref = &quot;release&quot;) RUVSeq for normalization using ERCC controls: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;RUVSeq&quot;) ROCR for performance estimations: install.packages(&quot;ROCR&quot;) limma for plotting Venn diagrams: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;limma&quot;) DESeq2 for identification of differentially expressed genes: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;DESeq2&quot;) scde for identification of differentially expressed genes: devtools::install_github(&quot;hms-dbmi/scde&quot;, build_vignettes = FALSE)  Installation on Mac OS X may require this additional gfortran library: curl -O http://r.research.att.com/libs/gfortran-4.8.2-darwin13.tar.bz2 sudo tar fvxz gfortran-4.8.2-darwin13.tar.bz2 -C / See the help page for additional support.  pheatmap for plotting heatmaps: install.packages(&quot;pheatmap&quot;) pcaMethods required by the pcaReduce package below for unsupervised clustering of scRNA-seq data: ## try http:// if https:// URLs are not supported source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;pcaMethods&quot;) pcaReduce for unsupervised clustering of scRNA-seq data (bioRxiv): devtools::install_github(&quot;JustinaZ/pcaReduce&quot;) Rtsne for unsupervised clustering of scRNA-seq data: install.packages(&quot;Rtsne&quot;) SC3 for unsupervised clustering of scRNA-seq data (bioRxiv): devtools::install_github(&quot;hemberg-lab/SC3&quot;, ref = &quot;R-old&quot;)  Before running SC3 for the first time only, please start R and enter:  RSelenium::checkForServer()  "],
["introduction-to-single-cell-rna-seq.html", "3 Introduction to single-cell RNA-seq 3.1 Bulk RNA-seq 3.2 scRNA-seq 3.3 Protocol 3.4 Computational Analysis 3.5 Challenges 3.6 Controls", " 3 Introduction to single-cell RNA-seq  3.1 Bulk RNA-seq  A major breakthrough (replaced microarrays) in the late 00’s and has been widely used since Measures the average expression level for each gene across a large population of input cells Useful for comparative transcriptomics, e.g. samples of the same tissue from different species Useful for quantifying expression signatures from ensembles, e.g. in disease studies Insufficient for studying heterogeneous systems, e.g. early development studies, complex tissues (brain) Does not provide insights into the stochastic nature of gene expression    3.2 scRNA-seq  A new technology, first publication by Tang et al in 2009 Measures the distribution of expression levels for each gene across a population of cells Allows to study new biological questions in which cell-specific changes in transcriptome are important, e.g. cell type identification, heterogeneity of cell responses, stochasticity of gene expression, inference of gene regulatory networks across the cells. Datasets range from \\(10^2\\) to \\(10^4\\) cells and increase in size every year Currently there are several different protocols in use, e.g. SMART-seq2, CELL-seq and Drop-seq Several computational analysis methods from bulk RNA-seq can be used In most cases computational analysis requires adaptation of the existing methods or development of new ones    3.3 Protocol    Figure 3.1: Single cell sequencing (taken from here)   Overall, experimental scRNA-seq protocols are similar to the methods used for bulk RNA-seq. For a discussion on experimental methods, please see reviews by Saliba et al, Handley et al or Kolodziejczyk et al.   3.4 Computational Analysis This course is concerned with the computational analysis of the data obtained from scRNA-seq experiments. The first steps (yellow) are general for any highthroughput sequencing data. Later steps (orange) require a mix of existing RNASeq analysis methods and novel methods to address the technical difference of scRNASeq. Finally the biological interpretation should be analyzed with methods specifically developed for scRNASeq.    Figure 3.2: Flowchart of the scRNA-seq analysis   Flowchart for analyzing scRNA-seq data.   3.5 Challenges The main difference between bulk and single cell RNA-seq is that each sequencing library represents a single cell, instead of a population of cells. Therefore, significant attention has to be paid to comparison of the results from different cells (sequencing libraries). The main sources of discrepancy between the libraries are:  Amplification (up to 1 million fold) Gene ‘dropouts’ in which a gene is observed at a moderate expression level in one cell but is not detected in another cell (Kharchenko et al).  In both cases the discrepancies are introduced due to low starting amounts of transcripts since the RNA comes from one cell only. Improving the transcript capture efficiency and reducing the amplification bias are currently active areas of research.   3.6 Controls To provide better estimates of the technical variation between scRNA sequencing libraries two quantitative standards are frequently used. The aim of using spike-ins and UMIs is to facilitate normalization of gene expression levels across different cells.  3.6.1 Spike-ins Spike-ins are extrinsic RNA molecules of known concentration which are added to the lysate of each cell prior to the reverse transcription reaction. The most popular and widely used spike-ins are synthetic spikes from the External RNA Control Consortium (ERCC). This set of 96 synthetic mRNAs of differing length and GC content based on bacterial sequences (Jiang et al.).   3.6.2 UMIs Another method of standardisation is to use Unique Molecular Identifiers (UMIs). These are 4-20 bp barcode sequences which are added to the 3’ or 5’ end of each transcript prior to amplification (typically during reverse transcription). This is usually followed by targetted sequencing of the respective end of the transcripts. The barcodes make it possible to quantify the number of transcripts prior to the amplification step.    "],
["construction-of-expression-matrix.html", "4 Construction of expression matrix 4.1 Reads QC 4.2 Reads alignment 4.3 Alignment example 4.4 Mapping QC 4.5 Reads quantification", " 4 Construction of expression matrix  4.1 Reads QC The output from a scRNA-seq experiment is a large collection of cDNA reads. The first step is to ensure that the reads are of high quality. The quality control can be performed by using standard tools, such as FastQC or Kraken. Assuming that our reads are in experiment.bam, we run FastQC as $&lt;path_to_fastQC&gt;/fastQC experiment.bam Below is an example of the output from FastQC for a dataset of 125 bp reads. The plot reveals a technical error which resulted in a couple bases failing to be read correctly in the centre of the read. However, since the rest of the read was of high quality this error will most likely have a negligible effect on mapping efficiency.    Figure 4.1: Example of FastQC output   Additionally, it is often helpful to visualize the data using the Integrative Genomics Browser (IGV) or SeqMonk.   4.2 Reads alignment After trimming low quality bases from the reads, the remaining sequences can be mapped to a reference genome. Again, there is no need for a special purpose method for this, so we can use the STAR or the TopHat aligner. An example of how to map reads.bam to using STAR is $&lt;path_to_STAR&gt;/STAR --runThreadN 1 --runMode alignReads --readFilesIn reads1.fq.gz reads2.fq.gz --readFilesCommand zcat --genomeDir &lt;path&gt; --parametersFiles FileOfMoreParameters.txt --outFileNamePrefix &lt;outpath&gt;/output Note, if the spike-ins are used, the reference sequence should be augmented with the DNA sequence of the spike-in molecules prior to mapping. Note, when UMIs are used, their barcodes should be removed from the read sequence. A good practice is to add the barcode to the read name. Once the reads for each cell have been mapped to the reference genome, we need to make sure that a sufficient number of reads from each cell could be mapped to the reference genome. In our experience, the fraction of mappable reads is 60-70%. However, this result may vary depending on protocol, read length and settings for the read alignment. As a general rule, we expect all cells to have a similar fraction of mapped reads, so any outliers should be inspected and possibly removed.   4.3 Alignment example The histogram below shows the total number of reads mapped to each cell for an scRNA-seq experiment. Each bar represents one cell, and they have been sorted in ascending order by the total number of reads per cell. The three red arrows indicate cells that are outliers in terms of their coverage and they should be removed from further analysis. The two yellow arrows point to cells with a surprisingly large number of unmapped reads. In this example we kept the cells during the alignment QC step, but they were later removed during cell QC due to a high proportion of ribosomal RNA reads.    Figure 4.2: Example of the total number of reads mapped to each cell.     4.4 Mapping QC After mapping the raw sequencing to the genome we need to evaluate the quality of the mapping. There are many ways to measure the mapping quality, including: amount of reads mapping to rRNA/tRNAs, proportion of uniquely mapping reads, reads mapping across splice junctions, read depth along the transcripts. Methods developed for bulk RNA-seq, such as RSeQC, are applicable to single-cell data: python &lt;RSeQCpath&gt;/geneBody_coverage.py -i input.bam -r genome.bed -o output.txt python &lt;RSeQCpath&gt;/bam_stat.py -i input.bam -r genome.bed -o output.txt python &lt;RSeQCpath&gt;/split_bam.py -i input.bam -r rRNAmask.bed -o output.txt However the expected results will depend on the experimental protocol, e.g. many scRNA-seq methods use poly-A selection to avoid sequencing rRNAs which results in a 3’ bias in the read coverage across the genes (aka gene body coverage). The figure below shows this 3’ bias as well as three cells which were outliers and removed from the dataset:    Figure 4.3: Example of the 3’ bias in the read coverage.     4.5 Reads quantification The next step is to quantify the expression level of each gene for each cell. For mRNA data, we can use one of the tools which has been developed for bulk RNA-seq data, e.g. HT-seq or FeatureCounts # include multimapping &lt;featureCounts_path&gt;/featureCounts -O -M -Q 30 -p -a genome.gtf -o outputfile input.bam # exclude multimapping &lt;featureCounts_path&gt;/featureCounts -Q 30 -p -a genome.gtf -o outputfile input.bam Note, when UMIs are used, the expression count is equal to the number of unique barcodes associated with all reads mapped to a given gene. UMI-tools provides several methods for obtaining the expression count and they also account for possible sequencing errors.   "],
["scater-package.html", "5 scater package 5.1 Introduction 5.2 scater workflow 5.3 Terminology 5.4 SCESet class", " 5 scater package  5.1 Introduction scater is a R package single-cell RNA-seq analysis. The package contains several useful methods for quality control, visualisation and pre-processing of data prior to further downstream analysis. scater features the following functionality:  Automated computation of QC metrics Transcript quantification from read data with pseudo-alignment Data format standardisation Rich visualizations for exploratory analysis Seamless integration into the Bioconductor universe Simple normalisation methods  We highly recommend to use scater for all single-cell RNA-seq analyses and scater is the basis of the first part of the course.   5.2 scater workflow       5.3 Terminology (this chapter is taken from the scater vignette)  The capabilities of scater are built on top of Bioconductor’s Biobase. In Bioconductor terminology we assay numerous “features” for a number of “samples”. Features, in the context of scater, correspond most commonly to genes or transcripts, but could be any general genomic or transcriptomic regions (e.g. exon) of interest for which we take measurements. In the following chapters it may be more intuitive to mentally replace “feature” with “gene” or “transcript” (depending on the context of the study) wherever “feature” appears. In the scater context, “samples” refer to individual cells that we have assayed.    5.4 SCESet class (this chapter is taken from the scater vignette) In scater we organise single-cell expression data in objects of the SCESet class. The class inherits the Bioconductor ExpressionSet class, which provides a common interface familiar to those who have analyzed microarray experiments with Bioconductor. The class requires three input files:  exprs, a numeric matrix of expression values, where rows are features, and columns are cells phenoData, an AnnotatedDataFrame object, where rows are cells, and columns are cell attributes (such as cell type, culture condition, day captured, etc.) featureData, an AnnotatedDataFrame object, where rows are features (e.g. genes), and columns are feature attributes, such as biotype, gc content, etc.  For more details about other features inherited from Bioconductor’s ExpressionSet class, type ?ExpressionSet at the R prompt. When the data are encapsulated in the SCESet class, scater will automatically calculate several different properties. This will be demonstrated in the subsequent chapters.   "],
["expression-qc-umi.html", "6 Expression QC (UMI) 6.1 Introduction 6.2 Blischak dataset 6.3 Cell QC 6.4 Cell filtering 6.5 Compare filterings 6.6 Gene filtering 6.7 Gene filtering 6.8 Save the data 6.9 Exercise", " 6 Expression QC (UMI)  6.1 Introduction Once gene expression has been quantified it is summarized as an expression matrix where each row corresponds to a gene (or transcript) and each column corresponds to a single cell. This matrix should be examined to remove poor quality cells which were not detected in either read QC or mapping QC steps. Failure to remove low quality cells at this stage may add technical noise which has the potential to obscure the biological signals of interest in the downstream analysis. Since there is currently no standard method for performing scRNASeq the expected values for the various QC measures that will be presented here can vary substantially from experiment to experiment. Thus, to perform QC we will be looking for cells which are outliers with respect to the rest of the dataset rather than comparing to independent quality standards. Consequently, care should be taken when comparing quality metrics across datasets collected using different protocols.   6.2 Blischak dataset To illustrate cell QC, we consider a dataset of induced pluripotent stem cells generated from three different individuals by John Blischak in Yoav Gilad’s lab at the University of Chicago. The experiments were carried out on the Fluidigm C1 platform and to facilitate the quantification both unique molecular identifiers (UMIs) and ERCC spike-ins were used. For our purposes you need to download the files annotation.txt, molecules.txt, and reads.txt into the blischak folder in your working directory. These files are the copies of the original files made on the 15/03/16. We will use these copies for reproducibility purposes. library(scater, quietly = TRUE) options(stringsAsFactors = FALSE) Load the data and annotations: molecules &lt;- read.table(&quot;blischak/molecules.txt&quot;, sep = &quot;\\t&quot;) anno &lt;- read.table(&quot;blischak/annotation.txt&quot;, sep = &quot;\\t&quot;, header = TRUE) Inspect a small portion of the expression matrix knitr::kable(     head(molecules[ , 1:3]), booktabs = TRUE,     caption = &#39;A table of the first 6 rows and 3 columns of the molecules table.&#39; )  Table 6.1: A table of the first 6 rows and 3 columns of the molecules table.    NA19098.r1.A01 NA19098.r1.A02 NA19098.r1.A03     ENSG00000237683 0 0 0   ENSG00000187634 0 0 0   ENSG00000188976 3 6 1   ENSG00000187961 0 0 0   ENSG00000187583 0 0 0   ENSG00000187642 0 0 0    knitr::kable(     head(anno), booktabs = TRUE,     caption = &#39;A table of the first 6 rows of the anno table.&#39; )  Table 6.2: A table of the first 6 rows of the anno table.   individual replicate well batch sample_id     NA19098 r1 A01 NA19098.r1 NA19098.r1.A01   NA19098 r1 A02 NA19098.r1 NA19098.r1.A02   NA19098 r1 A03 NA19098.r1 NA19098.r1.A03   NA19098 r1 A04 NA19098.r1 NA19098.r1.A04   NA19098 r1 A05 NA19098.r1 NA19098.r1.A05   NA19098 r1 A06 NA19098.r1 NA19098.r1.A06    The data consists of 3 individuals and 3 replicates and therefore has 9 batches in total. We standardize the analysis by using the scater package. First, create the scater SCESet classes: pheno_data &lt;- new(&quot;AnnotatedDataFrame&quot;, anno) rownames(pheno_data) &lt;- pheno_data$sample_id umi &lt;- scater::newSCESet(     countData = molecules,     phenoData = pheno_data ) Remove genes that are not expressed in any cell: keep_feature &lt;- rowSums(is_exprs(umi)) &gt; 0 umi &lt;- umi[keep_feature, ] Define control features (genes) - ERCC spike-ins and mitochondrial genes (provided by the authors): ercc &lt;- featureNames(umi)[grepl(&quot;ERCC-&quot;, featureNames(umi))] mt &lt;- c(&quot;ENSG00000198899&quot;, &quot;ENSG00000198727&quot;, &quot;ENSG00000198888&quot;,         &quot;ENSG00000198886&quot;, &quot;ENSG00000212907&quot;, &quot;ENSG00000198786&quot;,         &quot;ENSG00000198695&quot;, &quot;ENSG00000198712&quot;, &quot;ENSG00000198804&quot;,         &quot;ENSG00000198763&quot;, &quot;ENSG00000228253&quot;, &quot;ENSG00000198938&quot;,         &quot;ENSG00000198840&quot;) Calculate the quality metrics: umi &lt;- scater::calculateQCMetrics(     umi,     feature_controls = list(ERCC = ercc, MT = mt) )   6.3 Cell QC  6.3.1 Library size Next we consider the total number of RNA molecules detected per sample (if we were using read counts rather than UMI counts this would be the total number of reads). Wells with few reads/molecules are likely to have been broken or failed to capture a cell, and should thus be removed. hist(     umi$total_counts,     breaks = 100 ) abline(v = 25000, col = &quot;red&quot;)    Figure 6.1: Histogram of library sizes for all cells   Exercise Apply a suitable filter to remove the cells that contain too few molecules. What distribution do you expect that the total number of molecules for each cell should follow? Answer filter_by_total_counts &lt;- (umi$total_counts &gt; 25000) knitr::kable(     as.data.frame(table(filter_by_total_counts)),     booktabs = TRUE,     row.names = FALSE,     caption = &#39;The number of cells removed by total counts filter (FALSE)&#39; )  Table 6.3: The number of cells removed by total counts filter (FALSE)   filter_by_total_counts Freq     FALSE 46   TRUE 818      6.3.2 Detected genes (1) In addition to ensuring sufficient sequencing depth for each sample, we also want to make sure that the reads are distributed across the transcriptome. Thus, we count the total number of unique genes detected in each sample. hist(     umi$total_features,     breaks = 100 ) abline(v = 7000, col = &quot;red&quot;)    Figure 6.2: Histogram of the number of detected genes in all cells   From the plot we conclude that most cells have between 7,000-10,000 detected genes, which is normal for high-depth scRNA-seq. However, this varies by experimental protocol and sequencing depth. For example, droplet-based methods or samples with lower sequencing-depth typically detect fewer genes per cell. The most notable feature in the above plot is the “heavy tail” on the left hand side of the distribution. If detection rates were equal across the cells then the distribution should be approximately normal. Thus we remove those cells in the tail of the distribution (fewer than 7,000 detected genes). filter_by_expr_features &lt;- (umi$total_features &gt; 7000) knitr::kable(     as.data.frame(table(filter_by_expr_features)),     booktabs = TRUE,     row.names = FALSE,     caption = &#39;The number of cells removed by total features filter (FALSE)&#39; )  Table 6.4: The number of cells removed by total features filter (FALSE)   filter_by_expr_features Freq     FALSE 120   TRUE 744      6.3.3 ERCCs and MTs Another measure of cell quality is the ratio between ERCC spike-in RNAs and endogenous RNAs. This ratio can be used to estimate the total amount of RNA in the captured cells. Cells with a high level of spike-in RNAs had low starting amounts of RNA, likely due to the cell being dead or stressed which may result in the RNA being degraded. scater::plotPhenoData(     umi,     aes_string(x = &quot;total_features&quot;,                y = &quot;pct_counts_feature_controls_MT&quot;,                colour = &quot;batch&quot;) )    Figure 6.3: Percentage of counts in MT genes   scater::plotPhenoData(     umi,     aes_string(x = &quot;total_features&quot;,                y = &quot;pct_counts_feature_controls_ERCC&quot;,                colour = &quot;batch&quot;) )    Figure 6.4: Percentage of counts in ERCCs   The above analysis shows that majority of the cells from NA19098.r2 batch have a very high ERCC/Endo ratio. Indeed, it has been shown by the authors that this batch contains cells of smaller size. Exercise Create filters for removing batch NA19098.r2 and cells with high expression of mitochondrial genes (&gt;10% of total counts in a cell). Answer filter_by_ERCC &lt;- umi$batch != &quot;NA19098.r2&quot; knitr::kable(   as.data.frame(table(filter_by_ERCC)),   booktabs = TRUE,   row.names = FALSE,   caption = &#39;The number of cells removed by ERCC filter (FALSE)&#39; )  Table 6.5: The number of cells removed by ERCC filter (FALSE)   filter_by_ERCC Freq     FALSE 96   TRUE 768    filter_by_MT &lt;- umi$pct_counts_feature_controls_MT &lt; 10 knitr::kable(   as.data.frame(table(filter_by_MT)),   booktabs = TRUE,   row.names = FALSE,   caption = &#39;The number of cells removed by MT filter (FALSE)&#39; )  Table 6.6: The number of cells removed by MT filter (FALSE)   filter_by_MT Freq     FALSE 31   TRUE 833    Exercise What would you expect to see in the ERCC vs counts plot if you were examining a dataset containing cells of different sizes (eg. normal &amp; senescent cells)? Answer You would expect to see a group corresponding to the smaller cells (normal) with a higher fraction of ERCC reads than a separate group corresponding to the larger cells (senescent).    6.4 Cell filtering  6.4.1 Default By default scater will use 5-times the median absolute deviations (How is “deviation” defined?) from the median value as a threshold to filter cells according to the number of detected genes, total counts and percent of counts assigned to control genes (is this true? It seems odd that they would use a different method for this measure than the other) . In addition to any cells that have been marked as controls. umi$use_default &lt;- (     # remove cells with unusual numbers of genes     !umi$filter_on_total_features &amp;     # sufficient molecules counted     !umi$filter_on_total_counts &amp;     # sufficient endogenous RNA     !umi$filter_on_pct_counts_feature_controls_ERCC &amp;     # remove cells with unusual number of reads in MT genes     !umi$filter_on_pct_counts_feature_controls_MT &amp;     # controls shouldn&#39;t be used in downstream analysis     !umi$is_cell_control ) knitr::kable(   as.data.frame(table(umi$use_default)),   booktabs = TRUE,   row.names = FALSE,   caption = &#39;The number of cells removed by default filter (FALSE)&#39; )  Table 6.7: The number of cells removed by default filter (FALSE)   Var1 Freq     FALSE 6   TRUE 858      6.4.2 Automatic Another option available in scater is to conduct PCA on a set of QC metrics and then use automatic outlier detection to identify potentially problematic cells. By default, the following metrics are used for PCA-based outlier detection:  pct_counts_top_100_features total_features pct_counts_feature_controls n_detected_feature_controls log10_counts_endogenous_features log10_counts_feature_controls  umi &lt;- scater::plotPCA(umi,                 size_by = &quot;total_features&quot;,                  shape_by = &quot;filter_on_total_features&quot;,                 pca_data_input = &quot;pdata&quot;,                 detect_outliers = TRUE,                 return_SCESet = TRUE) ## The following cells/samples are detected as outliers: ## NA19098.r2.A01 ## NA19098.r2.A02 ## NA19098.r2.A06 ## NA19098.r2.A09 ## NA19098.r2.A10 ## NA19098.r2.A12 ## NA19098.r2.B01 ## NA19098.r2.B03 ## NA19098.r2.B04 ## NA19098.r2.B05 ## NA19098.r2.B07 ## NA19098.r2.B11 ## NA19098.r2.B12 ## NA19098.r2.C01 ## NA19098.r2.C02 ## NA19098.r2.C03 ## NA19098.r2.C04 ## NA19098.r2.C05 ## NA19098.r2.C06 ## NA19098.r2.C07 ## NA19098.r2.C08 ## NA19098.r2.C09 ## NA19098.r2.C10 ## NA19098.r2.C11 ## NA19098.r2.C12 ## NA19098.r2.D01 ## NA19098.r2.D02 ## NA19098.r2.D03 ## NA19098.r2.D04 ## NA19098.r2.D07 ## NA19098.r2.D08 ## NA19098.r2.D09 ## NA19098.r2.D10 ## NA19098.r2.D12 ## NA19098.r2.E01 ## NA19098.r2.E02 ## NA19098.r2.E03 ## NA19098.r2.E04 ## NA19098.r2.E05 ## NA19098.r2.E06 ## NA19098.r2.E07 ## NA19098.r2.E12 ## NA19098.r2.F01 ## NA19098.r2.F02 ## NA19098.r2.F07 ## NA19098.r2.F08 ## NA19098.r2.F09 ## NA19098.r2.F10 ## NA19098.r2.F11 ## NA19098.r2.F12 ## NA19098.r2.G01 ## NA19098.r2.G02 ## NA19098.r2.G03 ## NA19098.r2.G05 ## NA19098.r2.G06 ## NA19098.r2.G08 ## NA19098.r2.G09 ## NA19098.r2.G10 ## NA19098.r2.G11 ## NA19098.r2.H01 ## NA19098.r2.H02 ## NA19098.r2.H03 ## NA19098.r2.H04 ## NA19098.r2.H05 ## NA19098.r2.H06 ## NA19098.r2.H07 ## NA19098.r2.H08 ## NA19098.r2.H10 ## NA19098.r2.H12 ## NA19101.r3.A02 ## NA19101.r3.C12 ## NA19101.r3.D01 ## NA19101.r3.E08 ## Variables with highest loadings for PC1 and PC2: ##  ##                                            PC1         PC2 ## ---------------------------------  -----------  ---------- ## pct_counts_top_100_features          0.4771343   0.3009332 ## pct_counts_feature_controls          0.4735839   0.3309562 ## n_detected_feature_controls          0.1332811   0.5367629 ## log10_counts_feature_controls       -0.1427373   0.5911762 ## total_features                      -0.5016681   0.2936705 ## log10_counts_endogenous_features    -0.5081855   0.2757918    Figure 6.5: PCA plot used for automatic detection of cell outliers   knitr::kable(   as.data.frame(table(umi$outlier)),   booktabs = TRUE,   row.names = FALSE,   caption = &#39;The number of cells removed by automatic filter (FALSE)&#39; )  Table 6.8: The number of cells removed by automatic filter (FALSE)   Var1 Freq     FALSE 791   TRUE 73      6.4.3 Manual However, since we performed a more detailed analysis, visualized different features and defined our own filters we can use them instead of the default ones: umi$use &lt;- (     # sufficient features (genes)     filter_by_expr_features &amp;     # sufficient molecules counted     filter_by_total_counts &amp;     # sufficient endogenous RNA     filter_by_ERCC &amp;     # remove cells with unusual number of reads in MT genes     filter_by_MT ) knitr::kable(   as.data.frame(table(umi$use)),   booktabs = TRUE,   row.names = FALSE,   caption = &#39;The number of cells removed by manual filter (FALSE)&#39; )  Table 6.9: The number of cells removed by manual filter (FALSE)   Var1 Freq     FALSE 210   TRUE 654       6.5 Compare filterings Exercise Compare the default, automatic and manual cell filters. Plot a Venn diagram of the outlier cells from these filterings. Hint: Use limma::vennCounts and limma::vennDiagram functions from the limma package to make a Venn diagram. Answer def &lt;- colnames(umi)[!umi$use_default] auto &lt;- colnames(umi)[umi$outlier] man &lt;- colnames(umi)[!umi$use] venn.diag &lt;- limma::vennCounts(cbind(colnames(umi) %in% def,                                      colnames(umi) %in% auto,                                      colnames(umi) %in% man)) limma::vennDiagram(venn.diag,                    names = c(&quot;Default&quot;, &quot;Automatic&quot;, &quot;Manual&quot;),                    circle.col = c(&quot;magenta&quot;, &quot;blue&quot;, &quot;green&quot;))    Figure 6.6: Comparison of the default, automatic and manual cell filters     6.6 Gene filtering  6.6.1 Gene expression One can also look at the number of reads consumed by the top 50 expressed genes. scater::plotQC(umi, type = &quot;highest-expression&quot;)    Figure 6.7: Number of total counts consumed by the top 50 expressed genes   The distribution relatively flat indicating good coverage of the full transcriptome of these cell.    6.7 Gene filtering We can remove genes whose expression level is considered “undetectable”. We define a detectable gene expression level, in which at least two cells contain more than 1 read mapping to the gene. If we were considering read counts rather than UMI counts typically at least five reads in at least two cells is considered the threshold for detectability. Note that genes must be filtered after cell filtering since some genes may be only detected in poor quality cells. filter_genes &lt;- apply(counts(umi), 1, function(x) length(x[x &gt; 1]) &gt;= 2) fData(umi)$use &lt;- filter_genes knitr::kable(     as.data.frame(table(filter_genes)),     booktabs = TRUE,     row.names = FALSE,     caption = &#39;The number of genes removed by gene filter (FALSE)&#39; )  Table 6.10: The number of genes removed by gene filter (FALSE)   filter_genes Freq     FALSE 4512   TRUE 14214    Depending on the cell-type, protocol and sequencing depth, other cut-offs may be appropriate.   6.8 Save the data Dimensions of the QCed dataset (do not forget about the gene filter we defined above): dim(umi[fData(umi)$use, pData(umi)$use]) ## Features  Samples  ##    14214      654 Save the data: saveRDS(umi, file = &quot;blischak/umi.rds&quot;) If you want to further check yourself you can download our umi object. If you followed the steps above it should be exactly the same as yours.   6.9 Exercise Perform exactly the same QC analysis with read counts of the same Blischak data. Use blischak/reads.txt file to load the reads. Once you have finished please compare your results to ours (next chapter).   "],
["expression-qc-reads.html", "7 Expression QC (Reads)", " 7 Expression QC (Reads)  Table 7.1: A table of the first 6 rows and 3 columns of the molecules table.    NA19098.r1.A01 NA19098.r1.A02 NA19098.r1.A03     ENSG00000237683 0 0 0   ENSG00000187634 0 0 0   ENSG00000188976 57 140 1   ENSG00000187961 0 0 0   ENSG00000187583 0 0 0   ENSG00000187642 0 0 0     Table 7.2: A table of the first 6 rows of the anno table.   individual replicate well batch sample_id     NA19098 r1 A01 NA19098.r1 NA19098.r1.A01   NA19098 r1 A02 NA19098.r1 NA19098.r1.A02   NA19098 r1 A03 NA19098.r1 NA19098.r1.A03   NA19098 r1 A04 NA19098.r1 NA19098.r1.A04   NA19098 r1 A05 NA19098.r1 NA19098.r1.A05   NA19098 r1 A06 NA19098.r1 NA19098.r1.A06       Figure 7.1: Dropout rate vs mean expression      Figure 7.2: Number of total counts consumed by the top 50 expressed genes    Table 7.3: The number of genes removed by gene filter (FALSE)   filter_genes Freq     FALSE 2445   TRUE 16281       Figure 7.3: Histogram of library sizes for all cells    Table 7.4: The number of cells removed by total counts filter (FALSE)   filter_by_total_counts Freq     FALSE 180   TRUE 684       Figure 7.4: Histogram of the number of detected genes in all cells    Table 7.5: The number of cells removed by total features filter (FALSE)   filter_by_expr_features Freq     FALSE 16   TRUE 848       Figure 7.5: Library size vs number of detected genes      Figure 7.6: Percentage of counts in MT genes      Figure 7.7: Percentage of counts in ERCCs    Table 7.6: The number of cells removed by ERCC filter (FALSE)   filter_by_ERCC Freq     FALSE 103   TRUE 761     Table 7.7: The number of cells removed by MT filter (FALSE)   filter_by_MT Freq     FALSE 18   TRUE 846     Table 7.8: The number of cells removed by default filter (FALSE)   Var1 Freq     FALSE 37   TRUE 827    ## The following cells/samples are detected as outliers: ## NA19098.r1.B10 ## NA19098.r1.D07 ## NA19098.r1.E04 ## NA19098.r1.F06 ## NA19098.r1.H08 ## NA19098.r1.H09 ## NA19098.r2.A01 ## NA19098.r2.A06 ## NA19098.r2.A09 ## NA19098.r2.A12 ## NA19098.r2.B01 ## NA19098.r2.B11 ## NA19098.r2.B12 ## NA19098.r2.C04 ## NA19098.r2.C09 ## NA19098.r2.D02 ## NA19098.r2.D03 ## NA19098.r2.D09 ## NA19098.r2.E04 ## NA19098.r2.E07 ## NA19098.r2.F01 ## NA19098.r2.F11 ## NA19098.r2.G01 ## NA19098.r2.G05 ## NA19098.r2.G10 ## NA19098.r2.H01 ## NA19098.r2.H07 ## NA19098.r2.H08 ## NA19098.r2.H12 ## NA19098.r3.A05 ## NA19098.r3.A07 ## NA19098.r3.B02 ## NA19098.r3.C07 ## NA19098.r3.E05 ## NA19098.r3.E08 ## NA19098.r3.E09 ## NA19098.r3.F11 ## NA19098.r3.F12 ## NA19098.r3.G02 ## NA19098.r3.G03 ## NA19098.r3.G04 ## NA19098.r3.G11 ## NA19098.r3.G12 ## NA19098.r3.H08 ## NA19101.r1.A01 ## NA19101.r1.A12 ## NA19101.r1.B01 ## NA19101.r1.B06 ## NA19101.r1.E09 ## NA19101.r1.E11 ## NA19101.r1.F05 ## NA19101.r1.F10 ## NA19101.r1.G01 ## NA19101.r1.G06 ## NA19101.r1.H04 ## NA19101.r1.H09 ## NA19101.r2.A03 ## NA19101.r2.C10 ## NA19101.r2.E05 ## NA19101.r2.F02 ## NA19101.r2.H04 ## NA19101.r2.H10 ## NA19101.r3.A02 ## NA19101.r3.A03 ## NA19101.r3.A05 ## NA19101.r3.A09 ## NA19101.r3.B05 ## NA19101.r3.C01 ## NA19101.r3.C09 ## NA19101.r3.C12 ## NA19101.r3.D01 ## NA19101.r3.D04 ## NA19101.r3.D07 ## NA19101.r3.D09 ## NA19101.r3.E08 ## NA19101.r3.F09 ## NA19101.r3.G09 ## NA19101.r3.H01 ## NA19101.r3.H03 ## NA19101.r3.H07 ## NA19101.r3.H09 ## NA19239.r1.F05 ## NA19239.r1.G05 ## NA19239.r2.B01 ## NA19239.r2.B03 ## NA19239.r2.B10 ## NA19239.r2.B11 ## NA19239.r2.C03 ## NA19239.r2.C06 ## NA19239.r2.C08 ## NA19239.r2.D07 ## NA19239.r2.D09 ## NA19239.r2.E09 ## NA19239.r2.F04 ## NA19239.r2.F06 ## NA19239.r2.F07 ## NA19239.r2.F12 ## NA19239.r2.G03 ## NA19239.r2.G08 ## NA19239.r2.H02 ## NA19239.r2.H03 ## NA19239.r2.H07 ## NA19239.r3.A01 ## NA19239.r3.B09 ## NA19239.r3.C04 ## NA19239.r3.C07 ## NA19239.r3.E01 ## NA19239.r3.E03 ## NA19239.r3.E12 ## NA19239.r3.H02 ## NA19239.r3.H10 ## Variables with highest loadings for PC1 and PC2: ##  ##                                            PC1         PC2 ## ---------------------------------  -----------  ---------- ## pct_counts_feature_controls          0.5057646   0.2473134 ## pct_counts_top_100_features          0.4888852   0.2277068 ## n_detected_feature_controls          0.0231277   0.6235516 ## log10_counts_feature_controls       -0.1226860   0.6576822 ## total_features                      -0.4655518   0.2219694 ## log10_counts_endogenous_features    -0.5223679   0.1278782    Figure 7.8: PCA plot used for automatic detection of cell outliers    Table 7.9: The number of cells removed by automatic filter (FALSE)   Var1 Freq     FALSE 753   TRUE 111     Table 7.10: The number of cells removed by manual filter (FALSE)   Var1 Freq     FALSE 254   TRUE 610       Figure 7.9: Comparison of the default, automatic and manual cell filters   ## Features  Samples  ##    16281      610 If you want to further check yourself you can download our reads object. If you followed the steps above it should be exactly the same as yours.  "],
["expression-overview.html", "8 Expression overview 8.1 Introduction 8.2 PCA plot 8.3 tSNE map 8.4 Exercise", " 8 Expression overview  8.1 Introduction Here we will continue to work with the filtered blischak dataset produced in the previous chapter. We will look at what happened to the expression matrix after the quality control step. library(scater, quietly = TRUE) options(stringsAsFactors = FALSE) umi &lt;- readRDS(&quot;blischak/umi.rds&quot;) umi.qc &lt;- umi[fData(umi)$use, pData(umi)$use] endog_genes &lt;- !fData(umi.qc)$is_feature_control   8.2 PCA plot The easiest thing to overview the data is to transform it using the principal component analysis and then visualize the first two principal components. Again the scater package provides several very useful functions to make this analysis straightforward.  8.2.1 Before QC scater::plotPCA(umi[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 exprs_values = &quot;counts&quot;)    Figure 8.1: PCA plot of the blischak data     8.2.2 After QC scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 exprs_values = &quot;counts&quot;)    Figure 8.2: PCA plot of the blischak data      8.3 tSNE map Another way of representing the data is a tSNE map. We need to explain how tSNE works[dimensionality reduction + nearest neightbour network] &amp; show the effect of changing the parameters (Also these plots look to me like the perplexity parameter is too low.)  8.3.1 Before QC scater::plotTSNE(umi[endog_genes, ],                  colour_by = &quot;batch&quot;,                  size_by = &quot;total_features&quot;,                  exprs_values = &quot;counts&quot;,                  rand_seed = 123456)    Figure 8.3: tSNE map of the blischak data     8.3.2 After QC scater::plotTSNE(umi.qc[endog_genes, ],                  colour_by = &quot;batch&quot;,                  size_by = &quot;total_features&quot;,                  exprs_values = &quot;counts&quot;,                  rand_seed = 123456)    Figure 8.4: tSNE map of the blischak data      8.4 Exercise Perform the same analysis with read counts of the Blischak data. Use blischak/reads.rds file to load the reads SCESet object. Once you have finished please compare your results to ours (next chapter).   "],
["expression-overview-reads.html", "9 Expression overview (Reads)", " 9 Expression overview (Reads)    Figure 9.1: Proportion of reads accounted by the top 500      Figure 9.2: Proportion of reads accounted by the top 500      Figure 9.3: PCA plot of the blischak data      Figure 9.4: PCA plot of the blischak data      Figure 9.5: Diffusion map of the blischak data      Figure 9.6: Diffusion map of the blischak data      Figure 9.7: tSNE map of the blischak data      Figure 9.8: tSNE map of the blischak data    "],
["confounding-factors.html", "10 Confounding factors 10.1 Introduction 10.2 Correlations with PCs 10.3 Explanatory variables 10.4 Other confounders 10.5 Exercise", " 10 Confounding factors  10.1 Introduction There are a very large number of potential confounders, artifacts and biases in sc-RNA-seq data One of the main challenges in analyzing scRNA-seq data stems from the fact that it is difficult to carry out a true technical replicate (why?) to distinguish biological and technical variability. Exploring the effects of such variabilities (both those recorded during the experiment and computed QC metrics) is crucial for appropriate modeling of the data. The scater package provides a set of methods specifically for quality control of experimental and explanatory variables. Here we will continue to work with the Blischak data that was used in the previous chapter. library(scater, quietly = TRUE) options(stringsAsFactors = FALSE) umi &lt;- readRDS(&quot;blischak/umi.rds&quot;) umi.qc &lt;- umi[fData(umi)$use, pData(umi)$use] endog_genes &lt;- !fData(umi.qc)$is_feature_control The umi.qc dataset contains filtered cells and genes. Our next step is to explore technical drivers of variability in the data to inform data normalisation before downstream analysis.   10.2 Correlations with PCs Let’s first look again at the PCA plot of the QCed dataset: scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 exprs_values = &quot;counts&quot;)    Figure 10.1: PCA plot of the blischak data   scater allows one to identify principle components that correlate with experimental and QC variables of interest (it ranks principle components by \\(R^2\\) from a linear model regressing PC value against the variable of interest). Let’s test whether some of the variables correlate with any of the PCs.  10.2.1 Detected genes scater::plotQC(umi.qc[endog_genes, ],                type = &quot;find-pcs&quot;,                variable = &quot;total_features&quot;)    Figure 10.2: PC correlation with the number of detected genes   Indeed, we can see that PC1 can be completely explained by the number of the detected genes. In fact, it was also visible on the PCA plot above. This is a well-known issue in scRNA-seq and was described here.    10.3 Explanatory variables scater can also compute the marginal \\(R^2\\) for each variable when fitting a linear model regressing expression values for each gene against just that variable, and display a density plot of the gene-wise marginal \\(R^2\\) values for the variables. scater::plotQC(umi.qc[endog_genes, ],                type = &quot;expl&quot;,                exprs_values = &quot;counts&quot;,                variables = c(&quot;total_features&quot;,                              &quot;total_counts&quot;,                              &quot;batch&quot;,                              &quot;individual&quot;,                              &quot;pct_counts_feature_controls_ERCC&quot;,                              &quot;pct_counts_feature_controls_MT&quot;))    Figure 10.3: Explanatory variables   This analysis indicates that the number of detected genes (again) and also the sequencing depth (number of counts) have substantial explanatory power for many genes, so these variables are good candidates for conditioning out in a normalisation step, or including in downstream statistical models. Expression of ERCCs also appears to be an important explanatory variable.   10.4 Other confounders In addition to correcting for batch, there are other factors that one may want to compensate for. As with batch correction, these adjustments require extrinsic information. One popular method is scLVM which allows you to identify and subtract the effect from processes such as cell-cycle or apoptosis.   10.5 Exercise Perform the same analysis with read counts of the Blischak data. Use blischak/reads.rds file to load the reads SCESet object. Once you have finished please compare your results to ours (next chapter).   "],
["confounding-factors-reads.html", "11 Confounding factors (Reads)", " 11 Confounding factors (Reads)    Figure 11.1: PCA plot of the blischak data      Figure 11.2: PC correlation with the number of detected genes      Figure 11.3: PC correlation with the percentage of reads in ERCCs      Figure 11.4: PC correlation with the percentage of reads in MT genes    "],
["normalization-for-library-size.html", "12 Normalization for library size 12.1 Introduction 12.2 Library size 12.3 Normalisations 12.4 Interpretation 12.5 Other methods 12.6 Visualize genes 12.7 Exercise", " 12 Normalization for library size  12.1 Introduction In the previous chapter we identified important confounding factors and explanatory variables. scater allows one to account for these variables in subsequent statistical models or to condition them out using normaliseExprs(), if so desired. This can be done by providing a design matrix to normaliseExprs(). We are not covering this topic here, but you can try to do it yourself as an exercise. Instead we will explore how simple size-factor normalisations correcting for library size can remove the effects of some of the confounders and explanatory variables.   12.2 Library size Library sizes vary because of the various reasons: * scRNA-seq data is often sequenced on highly multiplexed platforms the total reads which are derived from each cell may differ substantially. * Protocols may differ in terms of their coverage of each transcript, their bias based on the average content of A/T nucleotides, or their ability to capture short transcripts. Ideally, we would like to compensate for all of these differences and biases when comparing data from two different experiments. Many methods to correct for library size have been developped for bulk RNA-seq and can be equally applied to scRNA-seq (eg. UQ, SF, CPM, RPKM, FPKM, TPM). Some quantification methods (eg. Cufflinks, RSEM) incorporated library size when determining gene expression estimates thus do not require this normalization. We will continue to work with the Blischak data that was used in the previous chapter and show how scater makes it easy to perform different types of size-factor normalizations. library(scater, quietly = TRUE) options(stringsAsFactors = FALSE) umi &lt;- readRDS(&quot;blischak/umi.rds&quot;) umi.qc &lt;- umi[fData(umi)$use, pData(umi)$use] endog_genes &lt;- !fData(umi.qc)$is_feature_control   12.3 Normalisations The simplest way to normalize this data is to convert it to counts per million (CPM) by dividing each column by its total then multiplying by 1,000,000. Note that spike-ins should be excluded from the calculation of total expression in order to correct for total cell RNA content, therefore we will only use endogenous genes. scater performs this normalisation by default, you can control it by changing exprs_values parameter to &quot;exprs&quot;. Another method is called TMM is the weighted trimmed mean of M-values (to the reference) proposed by Robinson and Oshlack (2010), where the weights are from the delta method on Binomial data. Another very popular method RLE is the scaling factor method proposed by Anders and Huber (2010). We call it “relative log expression”, as median library is calculated from the geometric mean of all columns and the median ratio of each sample to the median library is taken as the scale factor. A similar to RLE the upperquartile is the upper-quartile normalization method of Bullard et al (2010), in which the scale factors are calculated from the 75% quantile of the counts for each library, after removing genes which are zero in all libraries. This idea is generalized here to allow scaling by any quantile of the distributions. Let’s compare all these methods.  12.3.1 Raw scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 shape_by = &quot;individual&quot;,                 exprs_values = &quot;counts&quot;)    Figure 12.1: PCA plot of the blischak data     12.3.2 CPM scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 shape_by = &quot;individual&quot;,                 exprs_values = &quot;cpm&quot;)    Figure 12.2: PCA plot of the blischak data after CPM normalisation     12.3.3 log2(CPM) scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 shape_by = &quot;individual&quot;,                 exprs_values = &quot;exprs&quot;)    Figure 12.3: PCA plot of the blischak data after log2(CPM) normalisation     12.3.4 TMM umi.qc &lt;-      scater::normaliseExprs(umi.qc,                            method = &quot;TMM&quot;,                            feature_set = endog_genes,                            lib.size = rep(1, ncol(umi.qc))) scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 shape_by = &quot;individual&quot;,                 exprs_values = &quot;norm_counts&quot;)    Figure 12.4: PCA plot of the blischak data after TMM normalisation     12.3.5 RLE umi.qc &lt;-      scater::normaliseExprs(umi.qc,                            method = &quot;RLE&quot;,                            feature_set = endog_genes,                            lib.size = rep(1, ncol(umi.qc))) scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 shape_by = &quot;individual&quot;,                 exprs_values = &quot;norm_counts&quot;)    Figure 12.5: PCA plot of the blischak data after RLE normalisation     12.3.6 Upperquantile umi.qc &lt;-      scater::normaliseExprs(umi.qc,                            method = &quot;upperquartile&quot;,                             feature_set = endog_genes,                            p = 0.99,                            lib.size = rep(1, ncol(umi.qc))) scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 shape_by = &quot;individual&quot;,                 exprs_values = &quot;norm_counts&quot;)    Figure 12.6: PCA plot of the blischak data after UQ normalisation      12.4 Interpretation Clearly, only the CPM normalisation has reduced the effect of the number of detected genes and separated cells by individuals (though very weakly).   12.5 Other methods Some methods combine library size and fragment/gene length normalization such as:  RPKM - Reads Per Kilobase Million (for single-end sequencing) FPKM - Fragments Per Kilobase Million (same as RPKM but for paired-end sequencing, makes sure that paired ends mapped to the same fragment are not counted twice) TPM - Transcripts Per Kilobase Million (same as RPKM, but the order of normalizations is reversed - length first and sequencing depth second)  These methods are not applicable to our dataset since the end of the transcript which contains the UMI was preferentially sequenced. Furthermore in general these should only be calculated using appropriate quantification software from aligned BAM files not from read counts since often only a portion of the entire gene/transcript is sequenced, not the entire length. However, here we show how these normalisations can be calculated using scater. First, we need to find the effective transcript length in Kilobases. However, our dataset containes only gene IDs, therefore we will be using the gene lengths instead of transcripts. scater uses the biomaRt package, which allows one to annotate genes by other attributes: umi.qc &lt;-     scater::getBMFeatureAnnos(umi.qc,                               filters = &quot;ensembl_gene_id&quot;,                                attributes = c(&quot;ensembl_gene_id&quot;,                                              &quot;hgnc_symbol&quot;,                                              &quot;chromosome_name&quot;,                                              &quot;start_position&quot;,                                              &quot;end_position&quot;),                                feature_symbol = &quot;hgnc_symbol&quot;,                               feature_id = &quot;ensembl_gene_id&quot;,                               biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;,                                dataset = &quot;hsapiens_gene_ensembl&quot;,                               host = &quot;www.ensembl.org&quot;)  # If you have mouse data, change the arguments based on this example: # scater::getBMFeatureAnnos(object, #                           filters = &quot;ensembl_transcript_id&quot;,  #                           attributes = c(&quot;ensembl_transcript_id&quot;,  #                                        &quot;ensembl_gene_id&quot;, &quot;mgi_symbol&quot;,  #                                        &quot;chromosome_name&quot;, #                                        &quot;transcript_biotype&quot;, #                                        &quot;transcript_start&quot;, #                                        &quot;transcript_end&quot;,  #                                        &quot;transcript_count&quot;),  #                           feature_symbol = &quot;mgi_symbol&quot;, #                           feature_id = &quot;ensembl_gene_id&quot;, #                           biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;,  #                           dataset = &quot;mmusculus_gene_ensembl&quot;, #                           host = &quot;www.ensembl.org&quot;)  Some of the genes were not annotated, therefore we filter them out: umi.qc.ann &lt;-     umi.qc[!is.na(fData(umi.qc)$ensembl_gene_id), ] Now we compute the effective gene length in Kilobases by using the end_position and start_position fields: eff_length &lt;- abs(fData(umi.qc.ann)$end_position -                       fData(umi.qc.ann)$start_position)/1000 Now we are ready to perform the normalisations: tpm(umi.qc.ann) &lt;-     calculateTPM(         umi.qc.ann,         eff_length     ) fpkm(umi.qc.ann) &lt;-     calculateFPKM(         umi.qc.ann,         eff_length     ) Plot the results as a PCA plot: scater::plotPCA(umi.qc.ann,                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 shape_by = &quot;individual&quot;,                 exprs_values = &quot;fpkm&quot;)    Figure 12.7: PCA plot of the blischak data after FPKM normalisation   TPM normalisation produce a zero-matrix, we are not sure why, it maybe a bug in scater.   12.6 Visualize genes Now after the normalisation we are ready to visualise the gene expression:  12.6.1 Raw scater::plotExpression(umi.qc.ann,                        rownames(umi.qc.ann)[1:6],                        x = &quot;individual&quot;,                        exprs_values = &quot;counts&quot;,                        colour = &quot;batch&quot;)    Figure 12.8: Expression of the first 6 genes of the blischak data     12.6.2 CPM scater::plotExpression(umi.qc.ann,                        rownames(umi.qc.ann)[1:6],                        x = &quot;individual&quot;,                        exprs_values = &quot;cpm&quot;,                        colour = &quot;batch&quot;)    Figure 12.9: Expression of the first 6 genes of the blischak data after the CPM normalisation     12.6.3 log2(CPM) scater::plotExpression(umi.qc.ann,                        rownames(umi.qc.ann)[1:6],                        x = &quot;individual&quot;,                        exprs_values = &quot;exprs&quot;,                        colour = &quot;batch&quot;)    Figure 12.10: Expression of the first 6 genes of the blischak data after the log2(CPM) normalisation     12.6.4 Upperquantile scater::plotExpression(umi.qc.ann,                        rownames(umi.qc.ann)[1:6],                        x = &quot;individual&quot;,                        exprs_values = &quot;norm_counts&quot;,                        colour = &quot;batch&quot;)    Figure 12.11: Expression of the first 6 genes of the blischak data after the UQ normalisation     12.6.5 FPKM scater::plotExpression(umi.qc.ann,                        rownames(umi.qc.ann)[1:6],                        x = &quot;individual&quot;,                        exprs_values = &quot;fpkm&quot;,                        colour = &quot;batch&quot;)    Figure 12.12: Expression of the first 6 genes of the blischak data after the FPKM normalisation     12.6.6 TPM scater::plotExpression(umi.qc.ann,                        rownames(umi.qc.ann)[1:6],                        x = &quot;individual&quot;,                        exprs_values = &quot;tpm&quot;,                        colour = &quot;batch&quot;)    Figure 12.13: Expression of the first 6 genes of the blischak data after the TPM normalisation      12.7 Exercise Perform the same analysis with read counts of the Blischak data. Use blischak/reads.rds file to load the reads SCESet object. Once you have finished please compare your results to ours (next chapter).   "],
["normalization-for-library-size-reads.html", "13 Normalization for library size (Reads)", " 13 Normalization for library size (Reads)    Figure 13.1: PCA plot of the blischak data      Figure 13.2: PCA plot of the blischak data after CPM normalisation      Figure 13.3: PCA plot of the blischak data after log2(CPM) normalisation      Figure 13.4: PCA plot of the blischak data after TMM normalisation      Figure 13.5: PCA plot of the blischak data after RLE normalisation      Figure 13.6: PCA plot of the blischak data after UQ normalisation      Figure 13.7: PCA plot of the blischak data after FPKM normalisation      Figure 13.8: Expression of the first 6 genes of the blischak data      Figure 13.9: Expression of the first 6 genes of the blischak data after the CPM normalisation      Figure 13.10: Expression of the first 6 genes of the blischak data after the log2(CPM) normalisation      Figure 13.11: Expression of the first 6 genes of the blischak data after the UQ normalisation      Figure 13.12: Expression of the first 6 genes of the blischak data after the FPKM normalisation      Figure 13.13: Expression of the first 6 genes of the blischak data after the TPM normalisation    "],
["remove-confounders-using-controls.html", "14 Remove confounders using controls 14.1 Introduction 14.2 Brennecke method 14.3 Remove Unwanted Variation 14.4 Effectiveness 1 14.5 Effectiveness 2 14.6 Exercise", " 14 Remove confounders using controls  14.1 Introduction In the previous chapter we saw that the library size normalisation is able to remove major confounders. Let us see whether further use of the controls (ERCC and MT) can provide us with more insights into the data. Several methods (eg. BASiCS, scLVM, RUV) have been developed for normalisation using ERCCs using different noise models and different fitting procedures. We will demonstrate some of the methods starting from the simplest one proposed by Brennecke et al., which identifies genes with significant variation above technical noise (ERCCs). library(scRNA.seq.funcs) library(RUVSeq) library(scater, quietly = TRUE) options(stringsAsFactors = FALSE) umi &lt;- readRDS(&quot;blischak/umi.rds&quot;) umi.qc &lt;- umi[fData(umi)$use, pData(umi)$use] endog_genes &lt;- !fData(umi.qc)$is_feature_control   14.2 Brennecke method To use the method, we first normalize for library size then calculate the mean and the square coefficient of variation (variation divided by the squared mean expression). A curve is fit for the relationship between these two variables for the ERCC spike-in (subject to just technical variation) then a chi-square test is used to find genes significantly above the curve. This has been provided for you as the Brenneck_getVariableGenes(counts, spikes) function. umi.qc &lt;-      scater::normaliseExprs(umi.qc,                            method = &quot;RLE&quot;,                            feature_set = endog_genes,                            lib.size = rep(1, ncol(umi.qc))) erccs &lt;- grep(&quot;ERCC-&quot;, rownames(assayData(umi.qc)$norm_counts)) highly.var.genes &lt;- scRNA.seq.funcs::Brennecke_getVariableGenes(             assayData(umi.qc)$norm_counts,             erccs ) ## Loading required package: statmod ## Warning in scRNA.seq.funcs::Brennecke_getVariableGenes(assayData(umi.qc) ## $norm_counts, : Only 24 spike-ins to be used in fitting, may result in poor ## fit.    Figure 14.1: Results of using the Brennecke method on the Blischak dataset   In the figure above blue points are the ERCC spike-ins. The red curve is the fitted technical noise model and the dashed line is the 95% CI. Pink dots are the genes with significant biological variability after multiple-testing correction. Since our dataset is relatively homogeneous only 326 genes are identified as significantly variable.   14.3 Remove Unwanted Variation Factors contributing to technical noise frequently appear as “batch effects” where cells processed on different days or by different technicians systematically vary from one another. Removing technical noise and correcting for batch effects can frequently be performed using the same tool or slight variants on it. We will be considering the Remove Unwanted Variation (RUV) method which uses singular value decomposition (similar to PCA) on subsets of the dataset which should be invariant (e.g. ERCC spike-ins). Then the method removes the identified unwanted factors. assayData(umi.qc)$ruv_counts &lt;- RUVSeq::RUVg(     round(assayData(umi.qc)$norm_counts),     erccs,     k = 1)$normalizedCounts   14.4 Effectiveness 1 We evaluate the effectiveness of the normalization by inspecting the PCA plot where shape corresponds the technical replicate and colour corresponds to different biological samples (individuals from whom the iPSC lines where derived). Separation of biological samples and interspersed batches indicates that technical variation has been removed. scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 shape_by = &quot;individual&quot;,                 exprs_values = &quot;norm_counts&quot;)    Figure 14.2: PCA plot of the blischak data after RLE normalisation   scater::plotPCA(umi.qc[endog_genes, ],                 colour_by = &quot;batch&quot;,                 size_by = &quot;total_features&quot;,                 shape_by = &quot;individual&quot;,                 exprs_values = &quot;ruv_counts&quot;)    Figure 14.3: PCA plot of the blischak data after RLE and RUV normalisations     14.5 Effectiveness 2 We can also examine the relative log expression (RLE) across cells to confirm technical noise has been removed from the dataset. boxplot(list(scRNA.seq.funcs::calc_cell_RLE(assayData(umi.qc)$norm_counts),              scRNA.seq.funcs::calc_cell_RLE(assayData(umi.qc)$ruv_counts)))    Figure 14.4: Comparison of the relative log expression of the blischak data before and after the RUV normalisation     14.6 Exercise Perform the same analysis with read counts of the Blischak data. Use blischak/reads.rds file to load the reads SCESet object. Once you have finished please compare your results to ours (next chapter). Additionally, experiment with other combinations of normalizations and compare the results.   "],
["remove-confounders-using-controls-reads.html", "15 Remove confounders using controls (Reads)", " 15 Remove confounders using controls (Reads) ## Loading required package: statmod ## Warning in scRNA.seq.funcs::Brennecke_getVariableGenes(assayData(reads.qc) ## $norm_counts, : Only 17 spike-ins to be used in fitting, may result in poor ## fit. ## Warning in xy.coords(x, y, xlabel, ylabel, log): 7 x values &lt;= 0 omitted ## from logarithmic plot    Figure 15.1: Results of using the Brennecke method on the Blischak dataset      Figure 15.2: PCA plot of the blischak data after RLE normalisation      Figure 15.3: PCA plot of the blischak data after RLE and RUV normalisations      Figure 15.4: Comparison of the relative log expression of the blischak data before and after the RUV normalisation    "],
["clustering-analysis.html", "16 Clustering analysis 16.1 Introduction 16.2 Dimensionality reductions 16.3 Clustering methods 16.4 Challenges in clustering 16.5 Tools for scRNA-seq data", " 16 Clustering analysis Once we have normalized the data and removed confounders we can carry out analyses that will allow us to interpret the data biologically. The exact nature of the analysis depends on the dataset and the biological question at hand. Nevertheless, there are a few operations which are useful in a wide range of contexts and we will be discussing some of them. We will start with the clustering of scRNA-seq data.  16.1 Introduction One of the most promising applications of scRNA-seq is the discovery and annotation of cell-types based on the transcription profiles. Computationally, this is a hard problem as it amounts to unsupervised clustering. That is, we need to identify groups of cells based on the similarities of the transcriptomes without any prior knowledge of the labels. The problem is made more challenging due to the high level of noise and the large number of dimensions (i.e. genes).   16.2 Dimensionality reductions When working with large datasets, it can often be beneficial to apply some sort of dimensionality reduction method. By projecting the data onto a lower-dimensional sub-space, one is often able to significantly reduce the amount of noise. An additional benefit is that it is typically much easier to visualize the data in a 2 or 3-dimensional subspace. Here we will introduce some of the popular dimensionality reduction methods.  16.2.1 PCA Principal component analysis (PCA) is a statistical procedure that uses a transformation to convert a set of observations into a set of values of linearly uncorrelated variables called principal components (PCs). The number of principal components is less than or equal to the number of original variables. PCA is defined in such a way that the first principal component accounts for as much of the variability in the data as possible, and each succeeding component in turn has the highest variance possible under the constraint that it is orthogonal to the preceding components.    Figure 16.1: Schematic representation of PCA dimensionality reduction (taken from here)     16.2.2 Spectral Spectral decomposition is the factorization of a matrix into a canonical form, whereby the matrix is represented in terms of its eigenvalues and eigenvectors. In application to scRNA-seq data, the matrix can be either an input expression matrix, or matrix of distances between the cells. The computed eigenvectors are similar to the projections of the data to PCs (chapter 16.2.1).   16.2.3 tSNE    16.3 Clustering methods Unsupervised clustering is useful in many different applications and it has been widely studied in machine learning. Some of the most popular approaches are discussed below.  16.3.1 Hierarchical clustering In hierarchical clustering, one can use either a bottom-up or a top-down approach. In the former case, each cell is initially assigned to its own cluster and pairs of clusters are subsequently merged to create a hieararchy:    Figure 16.2: Raw data      Figure 16.3: The hierarchical clustering dendrogram   With a top-down strategy, one instead starts with all observations in one cluster and then recursively split each cluster to form a hierarchy. One of the advantages of this strategy is that the method is deterministic.   16.3.2 k-means In k-means clustering, the goal is to partition N cells into k different clusters. In an iterative manner, cluster centers are assigned and each cell is assigned to its nearest cluster:    Figure 16.4: Schematic representation of the k-means clustering   Most methods for scRNA-seq analysis includes a k-means step at some point.   16.3.3 Graph-based methods Over the last two decades there has been a lot of interest in analyzing networks in various domains. One goal is to identify groups or modules of nodes in a network. Some of these methods can be applied to scRNA-seq data and one example is the method, which is based on the concept of identifying groups of tightly connected nodes.    16.4 Challenges in clustering  What is the number of clusters k? Scalability: in the last 2 years the number of cells in scRNA-seq experiments has grown by 2 orders of magnitude from ~\\(10^2\\) to ~\\(10^4\\) Tools are not user-friendly    16.5 Tools for scRNA-seq data  16.5.1 SINCERA  Based on hierarchical clustering Data is converted to z-scores before clustering Identify k by finding the first singleton cluster in the hierarchy    16.5.2 pcaReduce  Based on PCA    16.5.3 SC3  Based on PCA and spectral dimensionality reductions Utilises k-means Additionally performs the consensus clustering    16.5.4 tSNE+k-means   16.5.5 SNN-Cliq       "]
]
